% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/functions.R
\name{flimoptim_Julia}
\alias{flimoptim_Julia}
\title{flimoptim_Julia}
\usage{
flimoptim_Julia(
  data,
  ndraw,
  sumstats,
  simulatorQ,
  julia_obj = NULL,
  nsim = 10,
  ninfer = 1,
  lower = 0,
  upper = 1,
  Theta0 = (lower + upper)/2,
  randomTheta0 = FALSE,
  AD = TRUE,
  method = "",
  maxit = 1000,
  time_lim = NULL,
  xtol = 0,
  ftol = 0,
  gtol = 1e-08,
  reltol = sqrt(.Machine$double.eps),
  abstol = .Machine$double.eps,
  show_trace = FALSE,
  store_trace = FALSE,
  store_quantiles = FALSE,
  par_names = NULL,
  load_julia = FALSE
)
}
\arguments{
\item{data}{1D array containing the observations.}

\item{ndraw}{Integer. Number of random variables to draw
for one simulation of the model.}

\item{sumstats}{Summary statistics to measure distance
between simulations and data.
String containing the script of the Julia function
sumstats(simulations, data).
The name "sumstats" is mandatory.}

\item{simulatorQ}{Simulator of the stochastic process
with fixed quantiles (see README).
simulatorQ(Theta, quantiles).
The name "simulatorQ" is mandatory.
Theta is the parameter set for the simulations and
quantiles are drawn in U(0,1).}

\item{julia_obj}{Objective function to minimize.
Default : is directly computed from sumstats and simulatorQ.
String containing the script of the Julia function
julia_obj(Theta, quantiles).
Warning : can be tricky to call data.
The name "julia_obj" is mandatory.}

\item{nsim}{Integer. Number of simulations to run for each step
of the optimization algorithm.
Computation time grows linearly with this number. Default to 10.}

\item{ninfer}{Integer. Number of independent inferences to run. Default to 1.}

\item{lower}{1D array. Lower bounds for parameters. Same length as upper.}

\item{upper}{1D array. Upper bounds for parameters. Same length as lower.}

\item{Theta0}{1D array. Initial values of the parameters.
Default : mean(lower, upper).}

\item{randomTheta0}{Boolean.
If True, Theta0 is randomly drawn between lower and upper bounds.}

\item{AD}{Boolean.
Only in Julia mod, uses Automatic Differentiation with IPNewton method.
Default to true.}

\item{method}{String.
Allows to choose the optimization method : "Brent", "IPNewton".
Default : IPNewton.}

\item{maxit}{Integer. Max number of iterations during optimization.
Default to 1000.}

\item{time_lim}{Float. Time limit in second for each inference.
Default to no limit. Not available for Brent method.}

\item{xtol}{Float. With IPNewton method : xtol option in Optim.Options.
Default to 0.}

\item{ftol}{Float. With IPNewton method : ftol option in Optim.Options.
Default to 0.}

\item{gtol}{Float. With IPNewton method : gtol option in Optim.Options.
Default to 1e-8.}

\item{reltol}{Float. With Brent method : reltol of Optim.optimize.
Default is sqrt(.Machine$double.eps), about 1e-8.}

\item{abstol}{Float. With Brent method : abstol of Optim.optimize.
Default is .Machine$double.eps, about 1e-16.}

\item{show_trace}{Boolean. If true, shows standard trace. Default to false.}

\item{store_trace}{Boolean.
If true, stores standard trace as an array of strings.
Default to false. Not available for R mod.}

\item{store_quantiles}{Boolean.
If true, stores every quantiles used for inference, to reproduce the results.
Default to false.}

\item{par_names}{vector of names for parameters.
Default is "par1", ..., "parn".}

\item{load_julia}{Boolean. If true, run julia_load. It can take few seconds.
Default to False.}
}
\value{
Object of class flimo_result (list) converted from Julia object
containing every information about convergence results.
}
\description{
Computes several parameter inferences with Julia optimizer and
either IPNewton with or without Automatic Differentiation or Brent method.
}
